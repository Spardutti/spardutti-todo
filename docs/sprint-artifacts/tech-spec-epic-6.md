# Epic Technical Specification: Auto-Update System

Date: 2025-11-24
Author: Spardutti
Epic ID: 6
Status: Draft

---

## Overview

Epic 6 implements a seamless auto-update system for spardutti-todo using electron-updater and GitHub Releases. This epic enables the application to automatically check for new versions on launch, download updates in the background, and install them on the next restart—all without disrupting the user's workflow. The system is designed with an offline-first philosophy: update checks fail gracefully when no internet connection is available, ensuring the app remains fully functional regardless of network status.

The implementation follows the architecture's deployment strategy, leveraging GitHub Releases as a free, reliable hosting platform for distributing NSIS installers and update metadata. The update flow is transparent to users: they're notified when an update is available, but never blocked from using the app. A manual update check (Ctrl+U) provides a fallback mechanism for troubleshooting or impatient users who want to verify they're on the latest version.

## Objectives and Scope

**In Scope:**
- Configure electron-updater library (v6.7.1) with GitHub Releases as update source
- Implement automatic update checks on application launch
- Implement background update download (non-blocking, no progress UI for MVP)
- Display update notifications in footer area using terminal-styled feedback
- Implement manual update check via Ctrl+U keyboard shortcut (fallback mechanism)
- Handle offline scenarios gracefully (no errors, silent failure)
- Implement `quitAndInstall()` on app close when update is ready
- Logging all update events via electron-log for debugging and support
- Test complete update flow with GitHub Releases (beta/pre-release tags for testing)

**Out of Scope:**
- Custom update server or self-hosted distribution (GitHub Releases only)
- Update progress bars or download percentage UI (background download, no visibility)
- Automatic rollback on failed updates (manual reinstall if needed)
- Delta updates or incremental patching (full installer download only)
- Code signing implementation (recommended for production, but not MVP blocker)
- Multi-version support or version pinning (always latest version)
- Update scheduling or "update on next launch" preferences (always install on quit)
- In-app changelog display (users can view GitHub Release notes manually)

## System Architecture Alignment

This epic aligns with the architecture's **Deployment Architecture** section, which specifies:
- electron-updater as the update mechanism (architecture decision: official Electron tooling)
- GitHub Releases as the hosting platform (zero-cost, reliable distribution)
- NSIS installer format (Windows-only target, generated by Electron Forge)
- Offline-first design (update check failures must not break app functionality)

**Component Locations:**
- Main process: `electron/updater.ts` (update configuration and event handlers)
- Main process: `electron/main.ts` (initialization of updater on app ready)
- Renderer IPC (if needed): Preload script exposes update status to renderer
- Renderer UI: Footer component displays update notifications via existing terminal-styled feedback system

**Dependencies:**
- electron-updater 6.7.1 (already installed per package.json)
- electron-log 5.4.1 (already configured for logging)
- GitHub repository with Releases enabled
- Electron Forge NSIS maker configuration

**Architecture Constraints:**
- No modal dialogs (inline footer notifications only per UX pattern decisions)
- No blocking UI (background downloads per performance considerations)
- Terminal aesthetic for all notifications (green text on black, no decorative elements)
- Keyboard-first interaction (Ctrl+U shortcut per consistency rules)

## Detailed Design

### Services and Modules

| Module | Responsibility | Inputs | Outputs | Owner/Location |
|--------|---------------|--------|---------|----------------|
| **UpdaterService** | Manages electron-updater lifecycle, event handling, and configuration | App launch event, manual check trigger (IPC) | Update status events (available, downloaded, error) | `electron/updater.ts` |
| **UpdaterInitializer** | Initializes updater on app ready, configures logger | App ready event | Initialized autoUpdater instance | `electron/main.ts` |
| **UpdateNotificationRenderer** | Displays update notifications in footer using terminal styling | Update status events (via IPC) | Footer UI updates (text changes) | `src/ui/render.ts` (or new `updateNotifications.ts`) |
| **KeyboardShortcutHandler** | Registers and handles Ctrl+U manual update check | Keydown event (Ctrl+U) | IPC message to main process to trigger check | `src/keyboard/KeyboardManager.ts` |
| **IPCBridge** | Facilitates communication between main and renderer for update status | Main process events, renderer requests | IPC messages (update-available, update-downloaded, check-for-updates) | `electron/preload.ts` |

### Data Models and Contracts

**Update Status Type (TypeScript Interface):**
```typescript
// src/types/UpdateStatus.ts
interface UpdateStatus {
  status: 'checking' | 'available' | 'not-available' | 'downloaded' | 'error'
  version?: string           // New version number (if available)
  message: string            // Display message for footer
  error?: string             // Error details (if status === 'error')
}
```

**latest.yml (electron-updater metadata file):**
```yaml
# Generated by Electron Forge NSIS maker
# Uploaded to GitHub Releases alongside .exe installer
version: 1.0.0
files:
  - url: spardutti-todo-Setup-1.0.0.exe
    sha512: [base64-encoded-hash]
    size: 85123456
path: spardutti-todo-Setup-1.0.0.exe
sha512: [base64-encoded-hash]
releaseDate: '2025-11-24T10:00:00.000Z'
```

**package.json fields (required for electron-updater):**
```json
{
  "name": "spardutti-todo",
  "version": "1.0.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/[username]/spardutti-todo.git"
  }
}
```

**No database schema changes:** All update data is transient (in-memory only, not persisted to todos.toon).

### APIs and Interfaces

**electron-updater API (Main Process):**
```typescript
// electron/updater.ts
import { autoUpdater } from 'electron-updater'
import log from 'electron-log'

export function initUpdater(mainWindow: BrowserWindow): void {
  // Configure logger
  autoUpdater.logger = log

  // Event handlers
  autoUpdater.on('checking-for-update', () => {
    log.info('Checking for updates...')
    mainWindow.webContents.send('update-status', {
      status: 'checking',
      message: 'Checking for updates...'
    })
  })

  autoUpdater.on('update-available', (info) => {
    log.info('Update available:', info.version)
    mainWindow.webContents.send('update-status', {
      status: 'available',
      version: info.version,
      message: 'Update available. Downloading...'
    })
  })

  autoUpdater.on('update-not-available', (info) => {
    log.info('Update not available:', info.version)
    mainWindow.webContents.send('update-status', {
      status: 'not-available',
      message: "You're on the latest version."
    })
  })

  autoUpdater.on('update-downloaded', (info) => {
    log.info('Update downloaded:', info.version)
    mainWindow.webContents.send('update-status', {
      status: 'downloaded',
      version: info.version,
      message: 'Update available. Restart to install.'
    })
  })

  autoUpdater.on('error', (error) => {
    log.error('Update error:', error)
    mainWindow.webContents.send('update-status', {
      status: 'error',
      message: 'Update check failed. Try again later.',
      error: error.message
    })
  })

  // Initial check on launch
  autoUpdater.checkForUpdatesAndNotify()
}

export function checkForUpdates(): void {
  autoUpdater.checkForUpdates()
}

export function quitAndInstall(): void {
  autoUpdater.quitAndInstall()
}
```

**IPC API (Preload Script):**
```typescript
// electron/preload.ts
import { contextBridge, ipcRenderer } from 'electron'

contextBridge.exposeInMainWorld('updater', {
  // Renderer → Main
  checkForUpdates: () => ipcRenderer.send('check-for-updates-manual'),

  // Main → Renderer (listener)
  onUpdateStatus: (callback: (status: UpdateStatus) => void) => {
    ipcRenderer.on('update-status', (_, status) => callback(status))
  }
})
```

**GitHub Releases API (External - HTTPS):**
- **Endpoint:** `https://api.github.com/repos/[user]/spardutti-todo/releases/latest`
- **Method:** GET (automatically called by electron-updater)
- **Response:** JSON with latest release metadata
- **Note:** electron-updater handles this internally; no manual API calls needed

**Window Type Declaration:**
```typescript
// src/types/window.d.ts
interface UpdaterAPI {
  checkForUpdates: () => void
  onUpdateStatus: (callback: (status: UpdateStatus) => void) => void
}

declare global {
  interface Window {
    updater: UpdaterAPI
  }
}
```

### Workflows and Sequencing

**Workflow 1: Automatic Update Check on Launch**
```
1. User launches spardutti-todo
2. Electron app.ready event fires
3. main.ts calls initUpdater(mainWindow)
4. updater.ts configures autoUpdater with logger
5. autoUpdater.checkForUpdatesAndNotify() is called
6. electron-updater queries GitHub API for latest release
   [IF OFFLINE] → Error event fires → Logged, no UI notification → END
   [IF NO UPDATE] → update-not-available event → Logged, no UI notification → END
   [IF UPDATE AVAILABLE] → Continue to step 7
7. update-available event fires → Send IPC to renderer
8. Renderer updates footer: "Update available. Downloading..."
9. electron-updater downloads .exe in background (non-blocking)
10. update-downloaded event fires → Send IPC to renderer
11. Renderer updates footer: "Update available. Restart to install." (persistent)
12. User continues using app normally
13. [LATER] User closes app (Esc or Ctrl+Q or window X)
14. main.ts app.on('before-quit') handler calls quitAndInstall()
15. App installs update and relaunches with new version
```

**Workflow 2: Manual Update Check (Ctrl+U)**
```
1. User presses Ctrl+U while app is open
2. KeyboardManager detects shortcut
3. Renderer calls window.updater.checkForUpdates()
4. Preload sends IPC 'check-for-updates-manual' to main
5. Main process handler calls autoUpdater.checkForUpdates()
6. Footer shows: "Checking for updates..." (2 seconds)
7. electron-updater queries GitHub API
   [IF UPDATE AVAILABLE] → Same as Workflow 1 steps 7-15
   [IF NO UPDATE] → Footer shows: "You're on the latest version." (3 seconds auto-hide)
   [IF ERROR] → Footer shows: "Update check failed. Try again later." (3 seconds auto-hide)
8. Footer returns to normal keyboard hints
```

**Workflow 3: Update Installation on Quit**
```
1. Update has been downloaded (status: 'downloaded')
2. User triggers quit (Esc, Ctrl+Q, or window close)
3. app.on('before-quit') event fires
4. main.ts checks if update is downloaded: autoUpdater.quitAndInstall()
5. App quits immediately
6. NSIS installer runs silently in background
7. Old version is replaced with new version
8. App relaunches automatically with new version
9. User sees app open with same todo list (data persisted)
```

**Workflow 4: Error Handling (Offline/Failed Check)**
```
1. Update check is triggered (launch or manual Ctrl+U)
2. Network is unavailable OR GitHub API fails
3. autoUpdater.on('error') event fires
4. error is logged via electron-log
5. [IF AUTOMATIC CHECK] → No UI notification (silent failure)
6. [IF MANUAL CHECK] → Footer shows: "Update check failed. Try again later." (3s)
7. App continues functioning normally (offline-first design)
```

**Sequence Diagram (Key Interactions):**
```
User          Renderer        Main Process       electron-updater      GitHub API
  |               |                |                     |                  |
  |--Launch App-->|                |                     |                  |
  |               |                |--app.ready--------->|                  |
  |               |                |<-initUpdater()------|                  |
  |               |                |--checkForUpdates--->|                  |
  |               |                |                     |--GET /releases-->|
  |               |                |                     |<-200 OK----------|
  |               |                |<-update-available---|                  |
  |               |<-IPC: status---|                     |                  |
  |               |--Footer: "Downloading..."            |                  |
  |               |                |                     |--Download .exe-->|
  |               |                |<-update-downloaded--|                  |
  |               |<-IPC: status---|                     |                  |
  |               |--Footer: "Restart to install"        |                  |
  |--Continue using app...         |                     |                  |
  |--Quit (Esc)-->|                |                     |                  |
  |               |                |--quitAndInstall()-->|                  |
  |               |                |<-App closes---------|                  |
  |               |                |     (NSIS installs silently)           |
  |               |                |<-App relaunches-----|                  |
  |<-App opens with new version--->|                     |                  |
```

## Non-Functional Requirements

### Performance

**Target:** Update operations must not impact the <2 second startup goal or block the UI during active use.

**Measurable Targets:**
- **Startup overhead:** Update check adds <200ms to app launch time (non-blocking check)
- **Background download:** No UI impact (download happens in separate thread, no progress bar)
- **Manual check response:** Ctrl+U triggers check within 100ms, footer updates immediately
- **Install time:** quitAndInstall() completes in <5 seconds (NSIS silent install)
- **Memory overhead:** electron-updater adds <10MB to app memory footprint
- **Network usage:** Single HTTPS GET request to GitHub API (~5KB), .exe download (50-80MB full installer)

**Performance Constraints from Architecture:**
- No animations or transitions (terminal constraint) - status changes must be instant
- Footer text updates must be synchronous (no perceived lag)
- Update check must not block input field focus on launch
- All operations logged but logging must not impact perceived performance

**Performance Testing:**
- Measure startup time with and without update check (target: <2s total)
- Test manual update check responsiveness (Ctrl+U → footer update in <100ms)
- Verify app remains responsive during background download (test with 100+ todos)
- Measure quitAndInstall() timing on test machine

### Security

**Update Source Security:**
- Updates hosted on GitHub Releases (trusted, HTTPS-only downloads)
- electron-updater validates HTTPS certificate for all API calls and downloads
- SHA512 hash validation: electron-updater verifies .exe integrity using latest.yml hashes
- No man-in-the-middle risk (HTTPS + hash validation)

**Code Signing (Production Recommendation):**
- **MVP:** Not required for initial release (acceptable for personal/beta use)
- **Production:** Strongly recommended to prevent Windows SmartScreen warnings
- Implementation: Sign .exe with EV code signing certificate before uploading to GitHub
- Note: Architecture document specifies this as "recommended for production"

**Attack Vectors Mitigated:**
- Malicious update injection: HTTPS + SHA512 validation prevents tampering
- DNS spoofing: HTTPS certificate validation
- Compromised GitHub account: User's responsibility to secure GitHub credentials (2FA recommended)

**Security Testing:**
- Verify HTTPS is used for all update-related network calls
- Test with self-signed certificate (should fail validation)
- Verify SHA512 mismatch causes update rejection

**Security Constraints:**
- No custom update server (GitHub only) - reduces attack surface
- No user-configurable update URLs - prevents social engineering attacks
- No update rollback mechanism - if compromised update is installed, manual reinstall required

### Reliability/Availability

**Offline-First Design:**
- App must function 100% if update check fails (FR9: offline access)
- Update check failure logged but never shown to user (automatic checks)
- No retry mechanism for failed checks (only on next launch or manual Ctrl+U)

**Graceful Degradation:**
- Network unavailable → Silent failure, app continues normally
- GitHub API rate limit → Error logged, no UI notification (automatic check)
- Corrupted download → electron-updater discards file, no install attempt
- Invalid latest.yml → Update check fails, app continues normally

**Availability Targets:**
- Core app functionality: 100% uptime (update system failures never crash app)
- Update check success rate: 95% (depends on GitHub uptime + user's internet)
- Update install success rate: 99% (NSIS installer is highly reliable)

**Error Recovery:**
- Failed update check: User can retry manually (Ctrl+U) or wait for next launch
- Failed download: User can retry manually or wait for next launch
- Failed install: User must manually download and install from GitHub Releases

**Reliability Testing:**
- Test with network disconnected (app must launch and function normally)
- Test with firewall blocking GitHub (same as offline scenario)
- Test with corrupted latest.yml (should fail gracefully, no crash)
- Test with GitHub API returning 404/500 (error logged, no UI impact)

### Observability

**Logging Strategy:**
- All update events logged via electron-log (configured in updater.ts)
- Log location: `%APPDATA%/spardutti-todo/logs/main.log`
- Log levels: info (normal events), error (failures)

**Logged Events:**
```typescript
// INFO level
log.info('Checking for updates...')
log.info('Update available:', { version: '1.1.0' })
log.info('Update not available:', { currentVersion: '1.0.0' })
log.info('Update downloaded:', { version: '1.1.0', size: '85MB' })

// ERROR level
log.error('Update check failed:', { error: error.message, stack: error.stack })
log.error('Download failed:', { error: error.message, url: downloadUrl })
```

**Metrics to Track (via logs):**
- Update check frequency (launches per day)
- Update availability rate (how often updates are found)
- Download success rate (completed downloads vs failures)
- Install success rate (inferred from version changes in logs)
- Error types and frequency (network, API, validation errors)

**User-Facing Signals:**
- Footer status messages (checking, available, downloaded, error)
- No separate logging UI needed (logs are for developer/support use)

**Debugging Support:**
- electron-log writes to file automatically (no configuration needed)
- Users can send `main.log` file for support troubleshooting
- Logs include timestamps, log levels, and contextual data (versions, error messages)

**Monitoring Gaps (Acceptable for MVP):**
- No telemetry or analytics (local-only tool, no phone-home)
- No crash reporting (logs only, manual user reports)
- No automated alerting (developer checks logs manually if user reports issue)

## Dependencies and Integrations

**External Dependencies (npm packages):**

| Package | Version | Purpose | Installation Status | License |
|---------|---------|---------|-------------------|---------|
| electron-updater | 6.7.1 | Auto-update client library | ✅ Installed (package.json) | MIT |
| electron-log | 5.4.1 | File-based logging | ✅ Installed (package.json) | MIT |
| electron | 39.2.3 | Desktop app framework | ✅ Installed (devDependency) | MIT |
| @electron-forge/maker-squirrel | 7.10.2 | NSIS installer maker | ✅ Installed (devDependency) | MIT |

**External Services (Cloud/API):**

| Service | Purpose | Endpoint | Authentication | SLA/Availability |
|---------|---------|----------|----------------|------------------|
| GitHub Releases | Hosting .exe installers and latest.yml | `https://api.github.com/repos/[user]/spardutti-todo/releases` | Public API (no auth for public repos) | 99.9% uptime (GitHub SLA) |
| GitHub CDN | Downloading .exe files | `https://github.com/[user]/spardutti-todo/releases/download/v1.0.0/*.exe` | None (public downloads) | Same as GitHub Releases |

**Internal Integrations:**

| Component | Integration Point | Data Exchanged | Protocol |
|-----------|------------------|----------------|----------|
| electron/updater.ts → electron/main.ts | Function call: `initUpdater(mainWindow)` | BrowserWindow reference | Direct function call |
| electron/updater.ts → Renderer | IPC: `webContents.send('update-status', status)` | UpdateStatus object | Electron IPC |
| Renderer → electron/main.ts | IPC: `ipcRenderer.send('check-for-updates-manual')` | Trigger signal | Electron IPC |
| electron/updater.ts → electron-log | Logger assignment: `autoUpdater.logger = log` | Log messages | Direct API call |
| KeyboardManager → window.updater | Function call: `window.updater.checkForUpdates()` | Trigger signal | Window API (preload exposed) |
| Footer component → UpdateStatus | State update: `setFooterMessage(status.message)` | Display text | Direct function call |

**Build-Time Dependencies:**

| Tool | Purpose | Version | Usage |
|------|---------|---------|-------|
| Electron Forge | Packaging and distribution | 7.10.2 | `npm run make` generates NSIS installer + latest.yml |
| NSIS | Windows installer builder | Bundled with Forge | Generates .exe installer (silent install capability) |
| GitHub CLI (gh) | Release creation and upload | Optional | `gh release create` uploads .exe and latest.yml |

**Configuration Dependencies:**

| File | Required Fields | Purpose |
|------|----------------|---------|
| package.json | `name`, `version`, `repository.url` | electron-updater reads these to construct GitHub API URLs |
| forge.config.ts | NSIS maker configuration | Generates latest.yml with SHA512 hashes for verification |

**Dependency Constraints:**
- electron-updater requires semantic versioning in package.json (e.g., "1.0.0", not "1.0")
- GitHub repository must be public OR release must be public for unauthenticated downloads
- NSIS installer must be built with Electron Forge (other builders may not generate latest.yml correctly)
- Windows-only: NSIS installer format is Windows-specific (no Mac/Linux support in this epic)

## Acceptance Criteria (Authoritative)

These criteria are extracted from Epic 6 stories and represent the complete Definition of Done for this epic.

**AC1: electron-updater Configuration (Story 6.1)**
- GIVEN electron-updater is installed
- WHEN I create electron/updater.ts with initUpdater() function
- THEN autoUpdater.logger is set to electron-log
- AND autoUpdater.checkForUpdatesAndNotify() is called on initialization
- AND update check logs appear in electron-log output
- AND the app doesn't crash if update check fails (offline mode works)

**AC2: package.json Repository Configuration (Story 6.1)**
- GIVEN package.json exists
- WHEN I add the repository field with GitHub repo URL
- THEN electron-updater can construct GitHub API URLs correctly
- AND version field is semantic (e.g., "1.0.0")

**AC3: forge.config.ts NSIS Configuration (Story 6.1)**
- GIVEN forge.config.ts exists
- WHEN I configure NSIS maker for Windows
- THEN `npm run make` generates .exe installer
- AND latest.yml metadata file is generated with SHA512 hashes
- AND installer supports silent installation (required for auto-update)

**AC4: Automatic Update Download and Notification (Story 6.2)**
- GIVEN a new version is available on GitHub Releases
- WHEN the app launches
- THEN electron-updater downloads the update in the background
- AND a notification appears in the footer: "Update available. Downloading..."
- AND the notification does not block app usage
- AND when download completes, footer shows: "Update available. Restart to install." (persistent)

**AC5: No Notification When No Update Available (Story 6.2)**
- GIVEN the app is on the latest version
- WHEN the app launches
- THEN no update notification appears
- AND update check is logged but silent to the user

**AC6: Update Installation on App Close (Story 6.2)**
- GIVEN an update has been downloaded
- WHEN I close the app (Esc, Ctrl+Q, or window X)
- THEN the app calls quitAndInstall()
- AND the NSIS installer runs silently
- AND the app relaunches with the new version
- AND todos.toon data persists (no data loss)

**AC7: Manual Update Check Trigger (Story 6.3)**
- GIVEN the app is running
- WHEN I press Ctrl+U
- THEN a manual update check is triggered
- AND the footer shows: "Checking for updates..." (2 seconds)

**AC8: Manual Check Feedback Messages (Story 6.3)**
- GIVEN I triggered a manual update check (Ctrl+U)
- WHEN the check completes
- THEN the footer shows the appropriate message:
  - IF update available: "Update available. Restart to install."
  - IF no update: "You're on the latest version." (auto-hide after 3 seconds)
  - IF check fails: "Update check failed. Try again later." (auto-hide after 3 seconds)

**AC9: Manual Check Debouncing (Story 6.3)**
- GIVEN I pressed Ctrl+U recently (within 10 seconds)
- WHEN I press Ctrl+U again
- THEN the check is debounced (no duplicate API calls)

**AC10: Successful Update Flow End-to-End (Story 6.4)**
- GIVEN version 0.1.0 is installed and version 0.2.0 is on GitHub Releases
- WHEN I launch the app on v0.1.0
- THEN the update check runs automatically
- AND the update downloads in the background
- AND notification appears: "Update available. Restart to install."
- AND when I close the app, it updates to v0.2.0
- AND the app relaunches with v0.2.0
- AND all todos persist correctly

**AC11: No Update Available Scenario (Story 6.4)**
- GIVEN I'm on the latest version
- WHEN I launch the app
- THEN the update check runs
- AND no notification appears (silent)
- AND the app continues normally

**AC12: Offline Mode Scenario (Story 6.4)**
- GIVEN I have no internet connection
- WHEN I launch the app
- THEN the update check fails silently
- AND no error notification appears
- AND the app continues normally (offline-first design)
- AND the error is logged in electron-log

**AC13: Manual Check Verification (Story 6.4)**
- GIVEN the app is running
- WHEN I press Ctrl+U
- THEN the footer shows "Checking for updates..."
- AND the appropriate result message appears based on availability

**AC14: Update Events Logged (Story 6.4)**
- GIVEN update operations occur
- WHEN I check %APPDATA%/spardutti-todo/logs/main.log
- THEN I see logged events:
  - "Checking for updates..."
  - "Update available: [version]" OR "Update not available"
  - "Update downloaded: [version]"
  - OR "Update error: [error message]" (if failed)

**AC15: Functional Requirements Coverage**
- FR22 (check updates automatically): Covered by AC1, AC4, AC10
- FR23 (auto-download and install): Covered by AC4, AC6, AC10
- FR24 (manual check fallback): Covered by AC7, AC8, AC13
- FR25 (update notifications): Covered by AC4, AC5, AC8

## Traceability Mapping

This table maps each acceptance criterion to the technical specification sections, components, and test ideas.

| AC | Spec Section(s) | Component(s)/API(s) | Test Idea |
|----|----------------|---------------------|-----------|
| **AC1** | Detailed Design → APIs and Interfaces | `electron/updater.ts` → `initUpdater()`, autoUpdater event handlers | Unit test: Verify logger is assigned. Integration test: Launch app offline, verify no crash |
| **AC2** | Dependencies and Integrations → Configuration Dependencies | `package.json` → `repository.url`, `version` | Manual verification: Check package.json fields exist. Unit test: Parse repository URL |
| **AC3** | Dependencies and Integrations → Build-Time Dependencies | `forge.config.ts` → NSIS maker config | Integration test: Run `npm run make`, verify .exe and latest.yml generated |
| **AC4** | Detailed Design → Workflows → Workflow 1 (Automatic Check) | `electron/updater.ts` → update-available event, Renderer → Footer component | Integration test: Mock GitHub API with new version, verify footer notification appears |
| **AC5** | Detailed Design → Workflows → Workflow 1 (Automatic Check) | `electron/updater.ts` → update-not-available event | Integration test: Mock GitHub API with same version, verify no footer notification |
| **AC6** | Detailed Design → Workflows → Workflow 3 (Installation on Quit) | `electron/main.ts` → before-quit handler, `autoUpdater.quitAndInstall()` | E2E test: Download update, close app, verify version change after relaunch |
| **AC7** | Detailed Design → Workflows → Workflow 2 (Manual Check) | `KeyboardManager` → Ctrl+U handler, IPC bridge → check-for-updates-manual | Integration test: Simulate Ctrl+U keypress, verify IPC message sent |
| **AC8** | Detailed Design → Workflows → Workflow 2 (Manual Check) | Renderer → Footer component, UpdateStatus messages | Integration test: Mock update check results, verify correct footer messages |
| **AC9** | Detailed Design → Services and Modules → KeyboardShortcutHandler | `KeyboardManager` → debounce logic for Ctrl+U | Unit test: Fire Ctrl+U twice within 5 seconds, verify only one API call |
| **AC10** | Detailed Design → Workflows → All 4 workflows | Full system (updater, IPC, renderer, installer) | E2E test: Full update flow from v0.1.0 → v0.2.0 using GitHub Releases |
| **AC11** | Detailed Design → Workflows → Workflow 1 (Automatic Check) | `electron/updater.ts` → update-not-available event | Integration test: Launch with latest version, verify silent check |
| **AC12** | NFR → Reliability/Availability → Offline-First Design | `electron/updater.ts` → error event handler | Integration test: Disable network, launch app, verify no error UI |
| **AC13** | Detailed Design → Workflows → Workflow 2 (Manual Check) | Full manual check flow (KeyboardManager → IPC → updater → footer) | E2E test: Press Ctrl+U in running app, verify footer messages |
| **AC14** | NFR → Observability → Logging Strategy | `electron/updater.ts` → electron-log integration, `%APPDATA%/logs/main.log` | Integration test: Trigger update check, verify log entries exist |
| **AC15** | Overview, Acceptance Criteria → FR Coverage | All components in Epic 6 | Regression test: Verify all FRs (FR22-FR25) are testable via AC1-AC14 |

## Risks, Assumptions, Open Questions

### Risks

**RISK-1: GitHub Releases Unavailable**
- **Description:** GitHub Releases experiences downtime or rate limiting
- **Impact:** Users cannot receive updates (update check fails)
- **Probability:** Low (GitHub 99.9% uptime SLA)
- **Mitigation:** Offline-first design ensures app continues functioning. Manual download from GitHub as fallback.
- **Owner:** External dependency (GitHub)

**RISK-2: NSIS Installer Fails on User's Machine**
- **Description:** Antivirus or Windows policies block NSIS installer execution
- **Impact:** Update downloads but fails to install silently
- **Probability:** Medium (Windows SmartScreen warnings without code signing)
- **Mitigation:** Log error for debugging. User can manually run installer. Recommend code signing for production.
- **Owner:** Dev team (consider code signing post-MVP)

**RISK-3: Network Latency on Large Downloads**
- **Description:** 50-80MB .exe download takes too long on slow connections
- **Impact:** Update download appears "stuck" to user (no progress bar in MVP)
- **Probability:** Medium (depends on user's internet speed)
- **Mitigation:** Background download doesn't block app usage. User can continue working. Consider progress bar in post-MVP iteration.
- **Owner:** UX design constraint (no progress bar per terminal aesthetic)

**RISK-4: Version Mismatch in package.json**
- **Description:** Developer forgets to update package.json version before release
- **Impact:** electron-updater cannot detect new version (update check returns "no update available")
- **Probability:** Medium (manual process)
- **Mitigation:** Document release process clearly. Add pre-release checklist. Consider automated version bumping in CI/CD.
- **Owner:** Dev team (process improvement)

**RISK-5: Corrupted Update Download**
- **Description:** Network interruption causes incomplete .exe download
- **Impact:** SHA512 validation fails, update rejected
- **Probability:** Low (electron-updater handles retries)
- **Mitigation:** electron-updater discards corrupted file. User retries on next launch or manual Ctrl+U.
- **Owner:** electron-updater library (built-in handling)

### Assumptions

**ASSUMPTION-1: GitHub Repository is Public**
- **Assumption:** GitHub repository will be public, allowing unauthenticated update checks
- **Validation:** Confirmed by project scope (no authentication requirements)
- **Impact if False:** Would need to implement GitHub personal access token for private repo updates
- **Next Step:** None (public repo is intentional)

**ASSUMPTION-2: Users Have Admin Rights on Windows**
- **Assumption:** Users can install/update software on their Windows machine (not restricted corporate environments)
- **Validation:** Target audience is developers/professionals with admin access
- **Impact if False:** NSIS installer may fail if user lacks admin privileges
- **Next Step:** Document requirement: "Admin rights required for installation"

**ASSUMPTION-3: Internet Connection on First Launch**
- **Assumption:** Users have internet on first app launch for initial update check
- **Validation:** Offline-first design handles offline scenario gracefully
- **Impact if False:** No update check occurs, but app functions normally
- **Next Step:** None (acceptable behavior)

**ASSUMPTION-4: NSIS Installer is Trusted**
- **Assumption:** Windows Defender/antivirus won't block unsigned NSIS installer (or user can override)
- **Validation:** Code signing recommended for production (post-MVP)
- **Impact if False:** Users see SmartScreen warning, may be hesitant to install
- **Next Step:** Consider code signing certificate for v1.0 public release

**ASSUMPTION-5: Users Want Automatic Updates**
- **Assumption:** Target users prefer seamless auto-updates over manual version checks
- **Validation:** Aligned with "flow state optimization" from PRD (zero friction)
- **Impact if False:** Would need to add "disable auto-update" setting
- **Next Step:** Monitor user feedback post-launch

### Open Questions

**QUESTION-1: Code Signing Timeline**
- **Question:** When should we implement code signing? MVP or post-MVP?
- **Context:** Code signing prevents Windows SmartScreen warnings but requires purchasing certificate ($200-400/year)
- **Decision Needed By:** Before v1.0 public release
- **Proposed Answer:** Post-MVP (acceptable risk for beta/personal use)

**QUESTION-2: Update Frequency**
- **Question:** How often should users receive updates? Every launch check or daily check?
- **Context:** Checking every launch may hit GitHub API rate limits for frequent users
- **Decision Needed By:** Story 6.1 implementation
- **Proposed Answer:** Every launch (simple, aligns with FR22). Rate limit risk is low for single-user app.

**QUESTION-3: Pre-release / Beta Channel**
- **Question:** Should we support beta/pre-release updates for testing?
- **Context:** GitHub Releases supports pre-release tags. electron-updater can filter by channel.
- **Decision Needed By:** Story 6.4 (testing phase)
- **Proposed Answer:** Use pre-release tags for testing, then switch to stable releases for production

**QUESTION-4: Update Rollback Mechanism**
- **Question:** Should we support rolling back to previous version if update causes issues?
- **Context:** Would require keeping old version or implementing version history
- **Decision Needed By:** Post-MVP (not critical for initial release)
- **Proposed Answer:** Out of scope for MVP. User can manually reinstall old version from GitHub Releases.

**QUESTION-5: Repository URL Configuration**
- **Question:** Should repository URL be hardcoded in package.json or configurable?
- **Context:** Hardcoded is simpler, configurable allows for forks/custom deployments
- **Decision Needed By:** Story 6.1 implementation
- **Proposed Answer:** Hardcoded in package.json (simpler, matches single-user tool philosophy)

## Test Strategy Summary

### Test Levels

**Unit Tests (Vitest)**
- **Scope:** Individual functions and modules in isolation
- **Coverage Targets:**
  - `electron/updater.ts`: initUpdater(), checkForUpdates() (mock autoUpdater)
  - `KeyboardManager`: Ctrl+U shortcut registration and debouncing logic
  - `UpdateStatus` type validation and message formatting
- **Framework:** Vitest (already configured in project)
- **Location:** Co-located with source files (e.g., `updater.test.ts`)
- **Run Frequency:** On every commit (pre-commit hook or CI)

**Integration Tests (Vitest + Electron Test Runner)**
- **Scope:** Component interactions, IPC communication, event handling
- **Test Scenarios:**
  - electron-updater event handlers trigger IPC messages correctly
  - Renderer receives update-status IPC and updates footer
  - KeyboardManager → IPC → Main process communication flow
  - electron-log captures update events correctly
- **Mocking:** Mock GitHub API responses using test fixtures
- **Environment:** Headless Electron instance for CI
- **Run Frequency:** On pull request merge, before release

**End-to-End Tests (Manual + Automated with Playwright/Spectron)**
- **Scope:** Full update flow from check → download → install → relaunch
- **Critical Paths:**
  - AC10: Successful update flow (v0.1.0 → v0.2.0)
  - AC11: No update available scenario
  - AC12: Offline mode scenario (graceful degradation)
  - AC13: Manual update check (Ctrl+U) verification
- **Environment:** Real GitHub Releases with beta/pre-release tags
- **Data:** Test with empty todos.toon and with 100+ todos (verify persistence)
- **Run Frequency:** Before each release, manual smoke testing

### Test Data & Fixtures

**Mock GitHub API Responses:**
```json
// latest-release-available.json
{
  "tag_name": "v1.1.0",
  "name": "Release 1.1.0",
  "assets": [
    {
      "name": "spardutti-todo-Setup-1.1.0.exe",
      "browser_download_url": "https://example.com/download.exe"
    }
  ]
}

// no-update-available.json
{
  "tag_name": "v1.0.0",  // Same as current version
  "name": "Release 1.0.0"
}

// api-error.json
{
  "message": "Not Found",
  "documentation_url": "https://docs.github.com/rest"
}
```

**Test Versions:**
- Current version: `1.0.0` (in package.json)
- Test update version: `1.0.1` (beta release on GitHub)
- Test major update: `2.0.0` (for major version change testing)

### Testing Tools

| Tool | Purpose | Usage |
|------|---------|-------|
| Vitest | Unit and integration tests | `npm test` |
| electron-mock-ipc | Mock IPC communication | Testing IPC message flows |
| nock | Mock HTTP requests | Mock GitHub API responses |
| Playwright / Spectron | E2E testing (optional) | Automate full update flow |
| electron-log-transporter | Test log output | Verify logging events |

### Edge Cases & Negative Scenarios

**Edge Case 1: Very Slow Network**
- **Test:** Simulate 56kbps connection, verify app remains responsive
- **Expected:** Background download proceeds, no UI freezing, user can continue working

**Edge Case 2: GitHub API Rate Limit (403)**
- **Test:** Mock GitHub 403 response with rate limit headers
- **Expected:** Error logged, footer shows "Update check failed. Try again later." (manual check only)

**Edge Case 3: Corrupted latest.yml**
- **Test:** Provide latest.yml with mismatched SHA512 hash
- **Expected:** Update rejected, error logged, no install attempt

**Edge Case 4: Multiple Rapid Ctrl+U Presses**
- **Test:** Press Ctrl+U 5 times within 2 seconds
- **Expected:** Only one update check fires (debouncing works)

**Edge Case 5: App Crashes During Update Download**
- **Test:** Kill app process mid-download
- **Expected:** Partial download discarded on next launch, update re-downloaded

**Edge Case 6: User Denies Admin Privileges for Install**
- **Test:** Run app as non-admin user, attempt install
- **Expected:** NSIS installer shows UAC prompt, install fails if denied, error logged

### Coverage Goals

**Code Coverage Targets:**
- `electron/updater.ts`: 90% line coverage (core update logic)
- IPC bridge (preload): 85% line coverage (communication layer)
- Renderer update notifications: 80% line coverage (UI feedback)
- Overall Epic 6 code: 85% average coverage

**Functional Coverage:**
- All 15 Acceptance Criteria must have at least one test
- All 4 Functional Requirements (FR22-FR25) covered by acceptance criteria tests
- All 4 update workflows tested (automatic, manual, install, error)

### Test Execution Strategy

**Development Phase:**
1. Write unit tests alongside implementation (TDD where applicable)
2. Run unit tests on file save (watch mode: `npm test -- --watch`)
3. Run integration tests before committing (pre-commit hook)

**PR Review Phase:**
1. CI runs full unit + integration test suite
2. Manual smoke test: Launch app, verify update check doesn't crash
3. Code coverage report in PR comments

**Pre-Release Phase:**
1. Create beta GitHub Release (e.g., v1.0.0-beta.1)
2. Run E2E test: Install current version → Update to beta → Verify success
3. Manual testing checklist:
   - [ ] Automatic update check on launch (online)
   - [ ] Automatic update check on launch (offline)
   - [ ] Manual update check (Ctrl+U)
   - [ ] Update download completes successfully
   - [ ] Update installs on app close
   - [ ] App relaunches with new version
   - [ ] todos.toon data persists after update
   - [ ] Logs contain expected update events

**Post-Release:**
1. Monitor electron-log submissions from users (if shared)
2. Track update success rate via GitHub Releases download counts
3. Regression testing on new Windows updates

### Known Testing Limitations

**Limitation 1: GitHub API Testing**
- Cannot fully test rate limiting without actual rate limit (risky to hit in tests)
- Mitigation: Use mock responses for most tests, manual test for rate limit scenario

**Limitation 2: NSIS Installer Testing**
- Cannot fully automate UAC prompt testing (requires user interaction)
- Mitigation: Manual testing for admin privileges scenarios

**Limitation 3: Network Interruption Simulation**
- Difficult to simulate partial download interruption reliably
- Mitigation: Trust electron-updater's built-in retry logic, test with network toggle

**Limitation 4: Multi-Version Compatibility**
- Cannot test all possible version upgrade paths (e.g., v0.5.0 → v2.0.0)
- Mitigation: Test sequential upgrades (v1.0.0 → v1.0.1 → v1.1.0), document breaking changes

### Test Deliverables

- ✅ Unit test files: `electron/updater.test.ts`, `KeyboardManager.test.ts`
- ✅ Integration test suite: `tests/integration/update-flow.test.ts`
- ✅ E2E test script: `tests/e2e/full-update-flow.spec.ts` (Playwright)
- ✅ Test fixtures: `tests/fixtures/github-api-responses.json`
- ✅ Test documentation: This section + inline test comments
- ✅ Pre-release checklist: Added to release process documentation

### Success Criteria for Testing

Epic 6 testing is considered complete when:
1. All 15 Acceptance Criteria have passing tests
2. Code coverage meets 85% target for Epic 6 components
3. E2E test completes successfully with real GitHub Release
4. Manual pre-release checklist passes 100%
5. No P0/P1 bugs found in testing phase
6. Offline scenario tested and works (app doesn't crash)
